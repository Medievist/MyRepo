# /etc/bashrc

# System wide functions and aliases
# Environment stuff goes in /etc/profile

# It's NOT good idea to change this file unless you know what you
# are doing. Much better way is to create custom.sh shell script in
# /etc/profile.d/ to make custom changes to environment. This will
# prevent need for merging in future updates.

# By default, we want this to get set.
# Even for non-interactive, non-login shells.
if [ "`id -gn`" = "`id -un`" -a `id -u` -gt 99 ]; then
	umask 002
else
	umask 022
fi

# are we an interactive shell?
if [ "$PS1" ]; then
    case $TERM in
	xterm*)
	    PROMPT_COMMAND='echo -ne "\033]0;${USER}@${HOSTNAME%%.*}:${PWD/#$HOME/~}"; echo -ne "\007"'
	    ;;
	screen)
	    PROMPT_COMMAND='echo -ne "\033_${USER}@${HOSTNAME%%.*}:${PWD/#$HOME/~}"; echo -ne "\033\\"'
	    ;;
	*)
	    ;;
    esac
    [ "$PS1" = "\\s-\\v\\\$ " ] && PS1="[\u@\h \W]\\$ "
    # You might want to have e.g. tty in prompt (e.g. more virtual machines)
    # and console windows
    # If you want to do so, just add e.g.
    # if [ "$PS1" ]; then
    #   PS1="[\u@\h:\l \W]\\$ "
    # fi
    # to your custom modification shell script in /etc/profile.d/ directory

    if [ -z "$loginsh" ]; then # We're not a login shell
	# Not all scripts in profile.d are compatible with other shells
	# TODO: make the scripts compatible or check the running shell by
	# themselves.
	if [ -n "${BASH_VERSION}${KSH_VERSION}${ZSH_VERSION}" ]; then
            for i in /etc/profile.d/*.sh; do
	        if [ -r $i ]; then
	            . $i
	        fi
	    done
	    unset i
	fi
    fi
fi

#My settings
if [ -f /etc/bash_completion ]; then
. /etc/bash_completion
fi
[ -z "$PS1" ] && return
if [[ $- != *i* ]] ; then
    return
fi
if [ -f /etc/DIR_COLORS ]; then
    eval `dircolors /etc/DIR_COLORS`
    export LS_OPTIONS='-F -T 0 --color=tty'
fi

export HISTIGNORE="&:ls:[bf]g:exit"
export HISTTIMEFORMAT='%d.%m.%Y %H:%M:%S '
export HISTCONTROL=ignorespace
export HISTCONTROL=erasedups
export HISTCONTROL=ignoredupsuname
export HISTCONTROL=ignoreboth
export HISTSIZE=1000
export EDITOR=vim
shopt -s checkwinsize
shopt -s cdspell
shopt -s histappend
shopt -s dotglob
[ -x /usr/bin/lesspipe.sh ] && eval "$(lesspipe.sh)"
LOCALHOST='whoami'



CYAN='\e[0;36m'
BCYAN='\e[1;36m'
GREEN='\e[0;32m'
BGREEN='\e[1;32m'
GREEN='\e[0;32m'
RED='\e[0;31m'
BRED='\e[1;31m'
RED_FG='\e[0;31m'
BLUE='\e[0;34m'
BBLUE='\e[1;34m'
SEAWAVE='\e[36m'
GREY='\e[30;1m'
YELLOW='\e[1;33m'
LYELLOW='\e[0;33m'
NC='\e[0;37m'
NORMAL='\e[00m'

PROMPT_COMMAND='history -a'

#if [[ "${DISPLAY#$HOST}" != ":0.0" &&  "${DISPLAY}" != ":0" ]]; then
#export PS1="${RED}\u${CYAN}@${BLUE}\h:${NC}\w# "
#fi

GRP=$(groups |sed 's/ .*//')
if [ "$GRP" != "$USER" ]; then
prompt_group=$GRP
fi
if [ $(hostname) = $LOCALHOST ]; then
# set a green prompt for my pc
prompt_color=$BGREEN
else
# set a red prompt everywhere else
prompt_color=$BRED
fi



clear
echo -e "${CYAN}This is BASH ${RED}${BASH_VERSION%.*}${CYAN} - DISPLAY on ${RED}$DISPLAY${NC}\n"
echo -ne ""; uname -vrn;
echo -ne "\033[1;32muptime:\033[0m"; uptime;
echo -ne "\033[1;32mDate: \033[0m"; date;
echo -ne "\033[1;31mAlert: console is owned by "; whoami
echo -ne "\n";
#PS1="\n${BGREEN}(${BRED}\$(smiley)${BGREEN})(\u|\H)-(\j)-(\t)-(\w)-(\$(/bin/ls -1 | /usr/bin/wc -l | /bin/sed 's: ::g') files, \$(/bin/ls -lah | /bin/grep -m 1 total | /bin/sed 's/total //')b)\n${BRED}>${YELLOW}>${BGREEN}> ${NORMAL}"
PS1="${BGREEN}[\u@\H]-(fg:\j)-(\t)-(\w)-hist:\! ${NC}\n$ "

alias path='echo -e ${PATH//:/\\n}'
alias rm="rm -i"
alias ls='ls --color=auto'
alias grep='grep --color=auto'
alias dir='ls --color=auto --format=vertical'
alias vdir='ls --color=auto --format=long'
alias ll='ls -l'
alias la='ls -A'
alias l='ls -CF'
alias ncmpc='ncmpc -c'
alias ping='ping -c 5'
alias ii=ii
alias bigdirs='du|sort -n|tail -20'
alias bigfiles='find -type f -print0|xargs -0 du|sort -n|tail -20'
alias exgrep='grep -v'
alias ssh='ssh -X -C -Y '
alias halt=dialog-halt

smiley() {
    err=$?
    if [ "$UID" == 0 ]; then
	user=root;
	if [ $err == 0 ]
	    then echo "$user :-)"
	else echo "$user -.- $err"
	fi
    else
	if [ $err == 0 ]
	    then echo ':-)'
	else echo "-.- $err"
	fi
    fi
}

function sleep() {
    if [ $1 ]; then
	if [ $1 = "standby" ] || [ $1 = "suspend" ] || [ $1 = "off" ]; then
	    $XSET dpms force $1
	else
	    echo "Usage: $0 standby|suspend|off"
#	    exit
	fi
    else
	echo "$0 usage: $0 standby|suspend|off"
#	exit
    fi
}

p_cpu() {
    ps -e -o pcpu,args --sort pcpu | sed '/^ 0.0 /d'
}

myip() {
    lynx -dump -hiddenlinks=ignore -nolist http://checkip.dyndns.org/
}

ext () {
    if [ -f $1 ] ; then
        case $1 in
            *.tar.bz2)   tar xjf $1        ;;
            *.tar.gz)    tar xzf $1     ;;
            *.bz2)       bunzip2 $1       ;;
            *.rar)       rar x $1     ;;
            *.gz)        gunzip $1     ;;
            *.tar)       tar xf $1        ;;
            *.tbz2)      tar xjf $1      ;;
            *.tgz)       tar xzf $1       ;;
            *.zip)       unzip $1     ;;
            *.Z)         uncompress $1  ;;
            *.7z)        7z x $1    ;;
            *)           echo "'$1' cannot be extracted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

pk () {
    if [ $1 ] ; then
	case $1 in
    	    tbz)   	tar cjvf $2.tar.bz2 *      ;;
            tgz)   	tar czvf $2.tar.gz  *   	;;
            tar)  	tar cpvf $2.tar  *       ;;
            bz2)	bzip * ;;
            gz)		gzip -c -9 -n * > $2.gz ;;
            zip)   	zip -r $2.zip *   ;;
            7z)    	7z a $2.7z *    ;;
            *)     	echo "'$1' cannot be packed via pk()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

psgrep() {
    if [ ! -z $1 ] ; then
        echo "Grepping for processes matching $1..."
		echo
		echo "USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND"
		ps aux | grep $1 | grep -v grep
    else
        echo "!! Need name to grep for"
    fi
}

genpass()
{
    cat /dev/urandom | tr -d -c 'a-zA-Z0-9' | fold -w 8 | head -1
}

function to_iso () {
    if [ $# = 0 ] || [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        echo -e "Converts raw, bin, cue, ccd, img, mdf, nrg cd/dvd image files to ISO image file. Usage ${RED_FG}'to_iso file1 file2...'$NC"
    fi
    for i in $*; do
        if [ ! -f "$i" ]; then
            echo "'$i' is not a valid file; jumping it"
        else
            echo -n "converting $i..."
            OUT=`echo $i | cut -d '.' -f 1`
            case $i in
                *.raw)              bchunk -v $i $OUT.iso;; #raw=bin #*.cue #*.bin
                *.bin|*.cue)        bin2iso $i $OUT.iso;;
                *.ccd|*.img)        ccd2iso $i $OUT.iso;; #Clone CD images
                *.mdf)              mdf2iso $i $OUT.iso;; #Alcohol images
                *.nrg)              nrg2iso $i $OUT.iso;; #nero images
                *)                  echo "to_iso don't know de extension of '$i'";;
            esac
            if [ $? != 0 ]; then
                echo -e "${RED_FG}ERROR!$NC"
            else
                echo -e "${GREEN_FG}done!$NC"
            fi
        fi
    done
}

function mount_iso () {
    local MOUNT_DIR=$HOME/mounted_iso
    if [ $# = 0 ] || [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        echo -e "Mount ISO files in '$MOUNT_DIR' folder . Usage ${RED_FG}'mount_iso isofile'$NC"
        return
    fi
    mkdir $MOUNT_DIR
    echo "mount directory $MOUNT_DIR created, mounting image..."
    sudo mount -o loop -t iso9660 $1 $MOUNT_DIR
    if [ $? != 0 ]; then
        echo -e "${RED_FG}ERROR!$NC deleting $MOUNT_DIR"
        rm -rfv $MOUNT_DIR
    else
        echo -e "${GREEN_FG}done!$NC for unmount type 'umount $MOUNT_DIR'"
    fi
}

function rmnpc () {
    if [ $# -eq 0 ] || [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        echo -e "Remove non printable characters from a files. Usage ${RED_FG}'rmnpc file1 file2...'$NC"
        return
    fi
    for file in $*; do
        if [ -f "$file" ]; then
            tr -cd '\11\12\40-\176' < $file > modified
            mv modified $file
        else
            echo "'$file' is not a valid file; jumping it"
        fi
    done
}

function my_ps () {
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        echo "Shows all the process of the current user. Usage ${RED_FG}'my_ps'$NC or ${RED_FG}'my_ps process1 process2...'$NC"
        return
    fi
    ps $@ -u $USER -o stat,pid,%cpu,%mem,bsdtime,command ;
}

function start() {
    sudo /etc/init.d/$1 start
}

function stop() {
    sudo /etc/init.d/$1 stop
}

function restart() {
    sudo /etc/init.d/$1 restart
}

function status() {
    sudo /etc/init.d/$1 status
}

function ii()   # Дополнительные сведения о системе
{
    echo -e "\nВы находитесь на " ; uname -n
    echo -e "\nДополнительная информация:$NC " ; uname -a
    echo -e "\nВ системе работают пользователи:$NC " ; w -h
    echo -e "\nДата:$NC " ; date
    echo -e "\nВремя, прошедшее с момента последней перезагрузки :$NC " ; uptime
    echo -e "\nПамять :$NC " ; free
    echo -e "\n"; myip ;
    echo
}

function srch () {
    if [ $# = 0 ] || [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        echo -e "Find a word in files under the current directory ignoring .svn, log files and backups. Usage ${RED_FG}'srch word'$NC"
        return
    fi
    grep -n -R $1 * | grep -v "\.svn" | grep -v "\.log" | grep -v "*~"
}

function p-s-c() {
	if [ "$1" = "--help" ] || [ "$1" = "-h" ] || [ $# -lt 3 ]; then
		echo -e "Use: p-s-c <pause process> <run command> <PID|COMMAND>"
		return
	fi
	if [ "$3" = "PID" ]; then
	    kill -STOP $1
	    if [ "$?" = 1 ]; then
		return
	    else
		$2
		kill -CONT $1
	    fi
	    return
	fi
	if [ "$3" = "COMMAND" ]; then
	    killall -STOP $1
	    if [ "$?" = 1 ]; then
		return
	    else
		$2
		killall -CONT $1
	    fi
	    return
	fi
	echo -e "Use: p-s-c <pause process> <run command> <PID|COMMAND>"
}

function random()
{
	if [ $# = 0 ] || [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
		echo -e "Generations random numbers. Usage ${RED_FG}'random <min> <max> <numbers>'$NC"
		return
    fi
	if [ $1 ]; then
		FLOOR=$1
	else
		FLOOR=0
	fi
	if [ $2 ]; then
		RANGE=$2
	else
		RANGE=1000000
	fi
	if [ $3 ]; then
		NUMBER=$3
	else
		NUMBER=1
	fi
	if [ "$2" -le "$1" ]; then
		echo "minimum should be greater than the maximum"
		return
	fi
	number=0   #initialize
	count=1
	while [ "$count" -le $NUMBER ]
		do
			while [ "$number" -le $FLOOR ]
				do
					number=$RANDOM
					let "number %= $RANGE"  # Ограничение "сверху" числом $RANGE.
			done
			let "count += 1"
			RANDOM=$(head -1 /dev/urandom | od -N 1 | awk '{ print $2 }')+$(date +%S)+$count
			echo "Случайное/сдучайные число/числа в диапазоне от $FLOOR до $RANGE ---  $number"
			number=0
		done
	echo
}

function trim_CR()
{
    E_WRONGARGS=65
    if [ -z "$1" ]; then
	echo "Порядок использования: `basename $0` filename-to-convert"
	exit $E_WRONGARGS
    fi

    NEWFILENAME=$1.unx
    CR='\015'  # Возврат каретки.
    # 015 -- это символ CR в восьмеричном формате
    # Строки в текстовых файлах DOS завершаются комбинацией символов CR-LF.
    tr -d $CR < $1 > $NEWFILENAME
    # Удалить символы CR и записать в новый файл.
    echo "Исходный текстовый файл: \"$1\"."
    echo "Преобразованный файл: \"$NEWFILENAME\"."
}

function trim_end_space()
{
    NEWFILENAME=$1.unx
    sed 's/[ \t]*$//' < $1 > $NEWFILENAME
    echo "Исходный текстовый файл: \"$1\"."
    echo "Преобразованный файл: \"$NEWFILENAME\"."
}

function trim_start_space()
{
    NEWFILENAME=$1.unx
    sed 's/^[ \t]*//' < $1 > $NEWFILENAME
    echo "Исходный текстовый файл: \"$1\"."
    echo "Преобразованный файл: \"$NEWFILENAME\"."
}

function large_file()
{
    find -type f -print0|xargs -0 du -b|sort -n|tail
}

function dialog-halt()
{
    DIALOG=${DIALOG=dialog}
    DISPLAY=$DISPLAY

    if [ "$DISPLAY" != ":0.0" ]; then
	$DIALOG --title " Выключение компьютера $DISPLAY" --clear \
	    --yesno "\nВы собираетесь выключить удаленную систему!!!\n\n             Вы хотите отказаться?" 10 50
    else
	exit
    fi

    case $? in
	0)
	    clear
	    $DIALOG --title "Отмена" --clear --msgbox "\nВы отказались от выключения удаленной системы" 7 50
	    clear;;
	1)
	    clear
	    /sbin/halt;;
	255)
	    $DIALOG --title "Отмена" --clear --msgbox "\nВы отказались от выключения удаленной системы" 7 50
	    clear;;
    esac
}

#End My settings
function my_help()
{
	case $1 in
		p_cpu)	echo "No parametrs"	;;
		myip)	echo "No parametrs"	;;
		pk)		echo "\"pk <ext> <name archiv file>"	;
				echo "ext=[tbz][tgz][tar][bz2][gz][zip][7z]"	;;
		ext)	echo "ext <name file>"	;;
		psgrep)	echo "psgrep <name process>"	;;
		*)	echo "\"p_cpu\" - Process used 0.0% CPU"	;
			echo "\"myip\" - My external IP" ;
			echo "\"pk\" - Packet dir with subdirs"	;
			echo "\"ext\" - Extract archiv"	;
			echo "\"psgrep\" - Grepping for processes";
			echo "\"genpass\" - Generation password";
			echo "\"mount_iso\" - Mount ISO files";
			echo "\"my_ps\" - Show all process of the curent user";
			echo "\"start\" - start services";
			echo "\"stop\" - stop services";
			echo "\"restart\" - restart services";
			echo "\"ii\" - Extendet info for systems";
			echo "\"srch\" - Find a word in files under the current directory ignoring .svn, log files and backups. Usage ${RED_FG}'srch word'$NC";
			echo "\"p-s-c\" - Pause process - run other command - for end command continue pause process";
			echo "\"random\" - Generate random numbers";
	esac
}

unset loginsh
